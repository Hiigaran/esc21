---
title: vectorize pi
layout: main
section: vectorization
---

In this exercises you will vectorize the computation of pi using the arc integral to optimize the execution time, while checking its result:

1. start from the pi.c code which reported also here:

       // #include <x86intrin.h>
       #include <math.h>
       #include <stdio.h>
       #include <sys/time.h>

       typedef double data_t;

       data_t pi(const long int num_steps) {

         const data_t one = 1.0;
         const data_t half = 0.5;
         const data_t four = 4.0;

         const data_t step =  one / (data_t)num_steps;

         data_t sum = 0;

         long int i;

         for (i=0; i< num_steps; i++) {

           data_t x = ( (data_t)i + half ) * step;

           sum += four / (one + x*x);

         }

         return step * sum;

       }


       int main() {

         const long int num_steps = 10000000;

         struct timeval start, stop;
         double time;

         // Start measuring time
         gettimeofday (&start, NULL);

         // Run compute function
         data_t result = pi(num_steps);

         // Stop measuring time
         gettimeofday (&stop, NULL);

         time = (double)(stop.tv_sec - start.tv_sec) + ((double)(stop.tv_usec - start.tv_usec)*1.0e-6);

         printf("Computed PI: %.16f Time to compute it: %.03f sec.\n", result, time );
         printf("Actual   PI: %.16f \n", M_PI );
         printf("Difference : %.16f \n", (M_PI-result) );

         return 0;
       }


2. compile with:

       gcc pi.c -o pi

   and execute the program

3. using ``objdump -d pi | less`` you can have a look to the instructions being generated by the compiler
   ( actually you can do the same in a more interactive way with this on-line tool: http://goo.gl/zI3WqS ).

4. try now to compile with:

       gcc -O3 pi.c -o pi

   and execute the program: is it faster? Is the result the same?
   how can we know if the code is being vectorized?

5. try now with these flags:

       gcc -O3 -fopt-info-vec-note pi.c -o pi

   why two loops? Have a look with objdump... try to define the pi function ``static inline``

6. try now with these flags:

       gcc -O3 -march=native -fopt-info-vec-note pi.c -o pi

   is it now vectorized? What changed in the instructions produced by the compiler? Can we go faster?

7. try now with these flags:

       gcc -Ofast -march=native -fopt-info-vec-note pi.c -o pi

   what happened to our result!? Which is the difference between ``-O3`` and ``-Ofast``? Try man gcc.

8. which of the ``-Ofast`` activated flags is affecting the numerical result and why?


